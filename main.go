/*
 * Datamonkey API
 *
 * Datamonkey is a free public server for comparative analysis of sequence alignments using state-of-the-art statistical models. <br> This is the OpenAPI definition for the Datamonkey API.
 *
 * API version: 1.0.0
 * Contact: spond@temple.edu
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	sw "github.com/d-callan/service-datamonkey/go"
)

// getEnvWithDefault returns environment variable value or default if not set
func getEnvWithDefault(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// getEnvWithFatal returns environment variable value or exits if not set
func getEnvWithFatal(key string) string {
	value := os.Getenv(key)
	if value == "" {
		log.Fatalf("%s is not set", key)
	}
	return value
}

// initDatasetTracker initializes and returns a dataset tracker based on environment configuration
func initDatasetTracker() sw.DatasetTracker {
	trackerType := getEnvWithDefault("DATASET_TRACKER_TYPE", "FileDatasetTracker")
	// for now we assume to put the tracker file, if needed, in the same directory as the datasets
	dataDir := getEnvWithDefault("DATASET_LOCATION", "/data/uploads")

	switch trackerType {
	case "FileDatasetTracker":
		return sw.NewFileDatasetTracker(filepath.Join(dataDir, "datasets.json"), dataDir)
	case "OtherTracker":
		log.Fatalf("OtherTracker is not implemented")
		return nil
	default:
		log.Fatalf("Unknown dataset tracker type: %s", trackerType)
		return nil
	}
}

// initJobTracker initializes and returns a job tracker based on environment configuration
func initJobTracker() sw.JobTracker {
	trackerType := getEnvWithDefault("JOB_TRACKER_TYPE", "FileJobTracker")
	trackerDir := getEnvWithDefault("JOB_TRACKER_LOCATION", "/data/uploads")

	switch trackerType {
	case "FileJobTracker":
		return sw.NewFileJobTracker(filepath.Join(trackerDir, "jobs.json"))
	case "OtherJobTracker":
		log.Fatalf("OtherJobTracker is not implemented")
		return nil
	default:
		log.Fatalf("Unknown job tracker type: %s", trackerType)
		return nil
	}
}

// initSlurmRestConfig initializes and returns Slurm REST configuration
func initSlurmRestConfig() sw.SlurmRestConfig {
	apiPath := getEnvWithFatal("SLURM_REST_API_PATH")
	// Use SLURM_REST_SUBMIT_API_PATH if set, otherwise fall back to SLURM_REST_API_PATH
	submitApiPath := getEnvWithDefault("SLURM_REST_SUBMIT_API_PATH", apiPath)
	baseURL := getEnvWithFatal("SLURM_REST_URL")

	// Get token refresh configuration with sensible defaults
	tokenRefreshHours := 12

	// Configure JWT token generation with hardcoded values for username and expiration
	jwtKeyPath := getEnvWithDefault("JWT_KEY_PATH", "/var/spool/slurm/statesave/jwt_hs256.key")
	jwtUsername := "slurm"
	jwtExpirationSecs := int64(86400) // 24 hours

	return sw.SlurmRestConfig{
		BaseURL:              baseURL,
		APIPath:              apiPath,
		SubmitAPIPath:        submitApiPath,
		QueueName:            getEnvWithFatal("SLURM_QUEUE_NAME"),
		AuthToken:            "", // Initial token will be generated
		TokenRefreshInterval: time.Duration(tokenRefreshHours) * time.Hour,
		JWTKeyPath:           jwtKeyPath,
		JWTUsername:          jwtUsername,
		JWTExpirationSecs:    jwtExpirationSecs,
	}
}

// initLocalSlurmConfig initializes and returns local Slurm configuration
func initLocalSlurmConfig() sw.SlurmConfig {
	// Get the partition from environment, with a default if not set
	partition := getEnvWithDefault("SLURM_PARTITION", "normal")
	
	// Create a basic configuration with only the critical parameter (partition)
	// Other parameters will use defaults or be set per-job
	return sw.SlurmConfig{
		Partition: partition,
		QueueName: getEnvWithDefault("SLURM_QUEUE_NAME", ""),
	}
}

// initScheduler initializes and returns a scheduler based on environment configuration
func initScheduler(jobTracker sw.JobTracker) sw.SchedulerInterface {
	schedulerType := getEnvWithDefault("SCHEDULER_TYPE", "SlurmRestScheduler")

	switch schedulerType {
	case "SlurmRestScheduler":
		config := initSlurmRestConfig()
		return sw.NewSlurmRestScheduler(config, jobTracker)
	case "SlurmScheduler":
		config := initLocalSlurmConfig()
		return sw.NewSlurmScheduler(config, jobTracker)
	default:
		log.Fatalf("Unknown scheduler type: %s", schedulerType)
		return nil
	}
}

// initAPIHandlers initializes the API handlers with the given components
func initAPIHandlers(scheduler sw.SchedulerInterface, datasetTracker sw.DatasetTracker) sw.ApiHandleFunctions {
	// Get HyPhy executable path from environment or use default
	hyPhyPath := getEnvWithDefault("HYPHY_PATH", "hyphy")
	// TODO: change this default so that upload files and log/ results are stored in a different directory
	basePath := getEnvWithDefault("HYPHY_BASE_PATH", "/data/uploads")

	return sw.ApiHandleFunctions{
		ABSRELAPI:          *sw.NewABSRELAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		FELAPI:             *sw.NewFELAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		BUSTEDAPI:          *sw.NewBUSTEDAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		SLACAPI:            *sw.NewSLACAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		MULTIHITAPI:        *sw.NewMULTIHITAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		GARDAPI:            *sw.NewGARDAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		MEMEAPI:            *sw.NewMEMEAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		FUBARAPI:           *sw.NewFUBARAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		CONTRASTFELAPI:     *sw.NewCONTRASTFELAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		RELAXAPI:           *sw.NewRELAXAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		BGMAPI:             *sw.NewBGMAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		NRMAPI:             *sw.NewNRMAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		FADEAPI:            *sw.NewFADEAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		SLATKINAPI:         *sw.NewSLATKINAPI(basePath, hyPhyPath, scheduler, datasetTracker),
		FileUploadAndQCAPI: *sw.NewFileUploadAndQCAPI(datasetTracker),
		HealthAPI:          sw.HealthAPI{Scheduler: scheduler},
	}
}

func main() {
	// Initialize components
	datasetTracker := initDatasetTracker()
	jobTracker := initJobTracker()
	scheduler := initScheduler(jobTracker)

	// Ensure proper shutdown of components
	if slurmScheduler, ok := scheduler.(*sw.SlurmRestScheduler); ok {
		// Set up graceful shutdown
		defer slurmScheduler.Shutdown()
		log.Println("Token refresh service initialized")
	}

	// Initialize API handlers
	routes := initAPIHandlers(scheduler, datasetTracker)

	// Start server
	port := getEnvWithDefault("SERVICE_DATAMONKEY_PORT", "9300")
	log.Printf("Server starting on port %s", port)
	if err := sw.NewRouter(routes).Run(fmt.Sprintf(":%s", port)); err != nil {
		log.Fatalf("Server error: %v", err)
	}
}
