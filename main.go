/*
 * Datamonkey API
 *
 * Datamonkey is a free public server for comparative analysis of sequence alignments using state-of-the-art statistical models. <br> This is the OpenAPI definition for the Datamonkey API.
 *
 * API version: 1.0.0
 * Contact: spond@temple.edu
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	sw "github.com/d-callan/service-datamonkey/go"
)

// getEnvWithDefault returns environment variable value or default if not set
func getEnvWithDefault(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// getEnvWithFatal returns environment variable value or exits if not set
func getEnvWithFatal(key string) string {
	value := os.Getenv(key)
	if value == "" {
		log.Fatalf("%s is not set", key)
	}
	return value
}

// initDatasetTracker initializes and returns a dataset tracker based on environment configuration
func initDatasetTracker() sw.DatasetTracker {
	trackerType := getEnvWithDefault("DATASET_TRACKER_TYPE", "SQLiteDatasetTracker")
	// for now we assume to put the tracker file, if needed, in the same directory as the datasets
	dataDir := getEnvWithDefault("DATASET_LOCATION", "/data/uploads")

	switch trackerType {
	case "FileDatasetTracker":
		return sw.NewFileDatasetTracker(filepath.Join(dataDir, "datasets.json"), dataDir)
	case "SQLiteDatasetTracker":
		dbPath := getEnvWithDefault("DATASET_TRACKER_DB_PATH", "/data/stores/datasets.db")
		tracker, err := sw.NewSQLiteDatasetTracker(dbPath, dataDir)
		if err != nil {
			log.Fatalf("Failed to initialize SQLite dataset tracker: %v", err)
		}
		return tracker
	case "OtherTracker":
		log.Fatalf("OtherTracker is not implemented")
		return nil
	default:
		log.Fatalf("Unknown dataset tracker type: %s", trackerType)
		return nil
	}
}

// initJobTracker initializes and returns a job tracker based on environment configuration
func initJobTracker() sw.JobTracker {
	trackerType := getEnvWithDefault("JOB_TRACKER_TYPE", "SQLiteJobTracker")
	trackerDir := getEnvWithDefault("JOB_TRACKER_LOCATION", "/data/uploads")

	switch trackerType {
	case "FileJobTracker":
		return sw.NewFileJobTracker(filepath.Join(trackerDir, "jobs.json"))
	case "SQLiteJobTracker":
		dbPath := getEnvWithDefault("JOB_TRACKER_DB_PATH", "/data/stores/jobs.db")
		tracker, err := sw.NewSQLiteJobTracker(dbPath)
		if err != nil {
			log.Fatalf("Failed to initialize SQLite job tracker: %v", err)
		}
		return tracker
	case "OtherJobTracker":
		log.Fatalf("OtherJobTracker is not implemented")
		return nil
	default:
		log.Fatalf("Unknown job tracker type: %s", trackerType)
		return nil
	}
}

// initSlurmRestConfig initializes and returns Slurm REST configuration
func initSlurmRestConfig() sw.SlurmRestConfig {
	apiPath := getEnvWithFatal("SLURM_REST_API_PATH")
	// Use SLURM_REST_SUBMIT_API_PATH if set, otherwise fall back to SLURM_REST_API_PATH
	submitApiPath := getEnvWithDefault("SLURM_REST_SUBMIT_API_PATH", apiPath)
	baseURL := getEnvWithFatal("SLURM_REST_URL")

	// Get token refresh configuration with sensible defaults
	tokenRefreshHours := 12

	// Configure JWT token generation with hardcoded values for username and expiration
	jwtKeyPath := getEnvWithDefault("JWT_KEY_PATH", "/var/spool/slurm/statesave/jwt_hs256.key")
	jwtUsername := "slurm"
	jwtExpirationSecs := int64(86400) // 24 hours

	return sw.SlurmRestConfig{
		BaseURL:              baseURL,
		APIPath:              apiPath,
		SubmitAPIPath:        submitApiPath,
		QueueName:            getEnvWithFatal("SLURM_QUEUE_NAME"),
		AuthToken:            "", // Initial token will be generated
		TokenRefreshInterval: time.Duration(tokenRefreshHours) * time.Hour,
		JWTKeyPath:           jwtKeyPath,
		JWTUsername:          jwtUsername,
		JWTExpirationSecs:    jwtExpirationSecs,
	}
}

// initLocalSlurmConfig initializes and returns local Slurm configuration
func initLocalSlurmConfig() sw.SlurmConfig {
	// Get the partition from environment, with a default if not set
	partition := getEnvWithDefault("SLURM_PARTITION", "normal")

	// Create a basic configuration with only the critical parameter (partition)
	// Other parameters will use defaults or be set per-job
	return sw.SlurmConfig{
		Partition: partition,
		QueueName: getEnvWithDefault("SLURM_QUEUE_NAME", ""),
	}
}

// initScheduler initializes and returns a scheduler based on environment configuration
func initScheduler(jobTracker sw.JobTracker) sw.SchedulerInterface {
	schedulerType := getEnvWithDefault("SCHEDULER_TYPE", "SlurmRestScheduler")

	switch schedulerType {
	case "SlurmRestScheduler":
		config := initSlurmRestConfig()
		return sw.NewSlurmRestScheduler(config, jobTracker)
	case "SlurmScheduler":
		config := initLocalSlurmConfig()
		return sw.NewSlurmScheduler(config, jobTracker)
	default:
		log.Fatalf("Unknown scheduler type: %s", schedulerType)
		return nil
	}
}

// initConversationTracker initializes the conversation tracker
func initConversationTracker() sw.ConversationTracker {
	// Get the tracker type from environment or use default
	trackerType := getEnvWithDefault("CONVERSATION_TRACKER_TYPE", "SQLiteConversationTracker")
	log.Printf("Initializing conversation tracker with type: %s", trackerType)

	switch trackerType {
	case "SQLiteConversationTracker":
		dbPath := getEnvWithDefault("CONVERSATION_DB_PATH", "./data/conversations.db")
		tracker, err := sw.NewSQLiteConversationTracker(dbPath)
		if err != nil {
			log.Fatalf("Failed to initialize SQLite conversation tracker: %v", err)
		}
		return tracker
	default:
		log.Fatalf("Unknown conversation tracker type: %s", trackerType)
		return nil
	}
}

// initTokenService initializes the token service for user authentication
func initTokenService() *sw.TokenService {
	// Check if token service is enabled
	enabled := getEnvWithDefault("USER_TOKEN_ENABLED", "true") == "true"
	if !enabled {
		log.Println("User token service is disabled")
		return nil
	}

	// Get JWT key path from environment or use default
	jwtKeyPath := getEnvWithDefault("USER_JWT_KEY_PATH", "")
	// Use SLURM JWT key if user key is not specified
	if jwtKeyPath == "" {
		slurmKeyPath := getEnvWithDefault("JWT_KEY_PATH", "")
		if slurmKeyPath != "" {
			log.Printf("Using Slurm JWT key for user tokens: %s", slurmKeyPath)
			jwtKeyPath = slurmKeyPath
		} else {
			log.Fatalf("No JWT key specified for user tokens")
			return nil
		}
	}

	// Get token expiration from environment or use default
	expirationSecs := int64(86400) // Default to 24 hours

	// Create token service config
	config := sw.TokenConfig{
		KeyPath:         jwtKeyPath,
		Username:        "datamonkey",
		ExpirationSecs:  expirationSecs,
		RefreshInterval: 12 * time.Hour,
	}

	log.Printf("Initializing token service with key path: %s", jwtKeyPath)
	return sw.NewTokenService(config)
}

// initAPIHandlers initializes the API handlers with the given components
func initAPIHandlers(scheduler sw.SchedulerInterface, datasetTracker sw.DatasetTracker, jobTracker sw.JobTracker, conversationTracker sw.ConversationTracker, tokenService *sw.TokenService) sw.ApiHandleFunctions {
	// Get HyPhy executable path from environment or use default
	hyPhyPath := getEnvWithDefault("HYPHY_PATH", "hyphy")
	// TODO: change this default so that upload files and log/ results are stored in a different directory
	basePath := getEnvWithDefault("HYPHY_BASE_PATH", "/data/uploads")

	// Initialize Genkit client for chat functionality
	modelConfig := sw.GetModelConfig()
	genkitClient, err := sw.NewGenkitClient(context.Background(), modelConfig)
	if err != nil {
		log.Fatalf("Failed to initialize Genkit client: %v", err)
	}
	
	// Create a user token validator if token service is available
	var tokenValidator *sw.UserTokenValidator
	if tokenService != nil {
		tokenValidator = sw.NewUserTokenValidator(tokenService)
		log.Println("User token validator initialized")
	} else {
		log.Println("Token service not available, user token validation will be disabled")
	}

	// Create API handlers
	absrelAPI := sw.NewABSRELAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	felAPI := sw.NewFELAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	bustedAPI := sw.NewBUSTEDAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	slacAPI := sw.NewSLACAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	multihitAPI := sw.NewMULTIHITAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	gardAPI := sw.NewGARDAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	memeAPI := sw.NewMEMEAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	fubarAPI := sw.NewFUBARAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	contrastfelAPI := sw.NewCONTRASTFELAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	relaxAPI := sw.NewRELAXAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	bgmAPI := sw.NewBGMAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	nrmAPI := sw.NewNRMAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	fadeAPI := sw.NewFADEAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	slatkinAPI := sw.NewSLATKINAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	
	// Set the UserTokenValidator for each API
	if tokenValidator != nil {
		absrelAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		felAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		bustedAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		slacAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		multihitAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		gardAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		memeAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		fubarAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		contrastfelAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		relaxAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		bgmAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		nrmAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		fadeAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
		slatkinAPI.HyPhyBaseAPI.UserTokenValidator = tokenValidator
	}

	return sw.ApiHandleFunctions{
		ABSRELAPI:          *absrelAPI,
		FELAPI:             *felAPI,
		BUSTEDAPI:          *bustedAPI,
		SLACAPI:            *slacAPI,
		MULTIHITAPI:        *multihitAPI,
		GARDAPI:            *gardAPI,
		MEMEAPI:            *memeAPI,
		FUBARAPI:           *fubarAPI,
		CONTRASTFELAPI:     *contrastfelAPI,
		RELAXAPI:           *relaxAPI,
		BGMAPI:             *bgmAPI,
		NRMAPI:             *nrmAPI,
		FADEAPI:            *fadeAPI,
		SLATKINAPI:         *slatkinAPI,
		FileUploadAndQCAPI: *sw.NewFileUploadAndQCAPI(datasetTracker),
		HealthAPI:          sw.HealthAPI{Scheduler: scheduler},
		ChatAPI:            *sw.NewChatAPI(genkitClient, conversationTracker, tokenService),
	}
}

func main() {
	// Initialize components
	log.Printf("Initializing dataset tracker with type: %s", getEnvWithDefault("DATASET_TRACKER_TYPE", "SQLiteDatasetTracker"))
	datasetTracker := initDatasetTracker()
	log.Printf("Initializing job tracker with type: %s", getEnvWithDefault("JOB_TRACKER_TYPE", "SQLiteJobTracker"))
	jobTracker := initJobTracker()
	conversationTracker := initConversationTracker()
	scheduler := initScheduler(jobTracker)
	tokenService := initTokenService()

	// Ensure proper shutdown of components
	if slurmScheduler, ok := scheduler.(*sw.SlurmRestScheduler); ok {
		// Set up graceful shutdown
		defer slurmScheduler.Shutdown()
		log.Println("Token refresh service initialized")
	}

	// Initialize API handlers
	routes := initAPIHandlers(scheduler, datasetTracker, jobTracker, conversationTracker, tokenService)

	// Start server
	port := getEnvWithDefault("SERVICE_DATAMONKEY_PORT", "9300")
	log.Printf("Server starting on port %s", port)
	if err := sw.NewRouter(routes).Run(fmt.Sprintf(":%s", port)); err != nil {
		log.Fatalf("Server error: %v", err)
	}
}
