/*
 * Datamonkey API
 *
 * Datamonkey is a free public server for comparative analysis of sequence alignments using state-of-the-art statistical models. <br> This is the OpenAPI definition for the Datamonkey API.
 *
 * API version: 1.0.0
 * Contact: spond@temple.edu
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	sw "github.com/d-callan/service-datamonkey/go"
)

// getEnvWithDefault returns environment variable value or default if not set
func getEnvWithDefault(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// getEnvWithFatal returns environment variable value or exits if not set
func getEnvWithFatal(key string) string {
	value := os.Getenv(key)
	if value == "" {
		log.Fatalf("%s is not set", key)
	}
	return value
}

// initUnifiedDB initializes the unified database and enables WAL mode
func initUnifiedDB() *sw.UnifiedDB {
	dbPath := getEnvWithDefault("DATAMONKEY_DB_PATH", "/data/stores/datamonkey.db")
	log.Printf("Initializing unified database at: %s", dbPath)

	// Ensure the database directory exists
	dbDir := filepath.Dir(dbPath)
	if err := os.MkdirAll(dbDir, 0755); err != nil {
		log.Fatalf("Failed to create database directory %s: %v", dbDir, err)
	}
	log.Printf("Database directory verified: %s", dbDir)

	db, err := sw.NewUnifiedDB(dbPath)
	if err != nil {
		log.Fatalf("Failed to initialize unified database: %v", err)
	}

	// Enable WAL mode for better concurrency
	if _, err := db.GetDB().Exec("PRAGMA journal_mode=WAL;"); err != nil {
		log.Fatalf("Failed to enable WAL mode: %v", err)
	}

	return db
}

// initSlurmRestConfig initializes and returns Slurm REST configuration
func initSlurmRestConfig() sw.SlurmRestConfig {
	apiPath := getEnvWithFatal("SLURM_REST_API_PATH")
	// Use SLURM_REST_SUBMIT_API_PATH if set, otherwise fall back to SLURM_REST_API_PATH
	submitApiPath := getEnvWithDefault("SLURM_REST_SUBMIT_API_PATH", apiPath)
	baseURL := getEnvWithFatal("SLURM_REST_URL")

	// Get token refresh configuration with sensible defaults
	tokenRefreshHours := 12

	// Configure JWT token generation with hardcoded values for username and expiration
	jwtKeyPath := getEnvWithDefault("JWT_KEY_PATH", "/var/spool/slurm/statesave/jwt_hs256.key")
	jwtUsername := "slurm"
	jwtExpirationSecs := int64(86400) // 24 hours

	return sw.SlurmRestConfig{
		BaseURL:              baseURL,
		APIPath:              apiPath,
		SubmitAPIPath:        submitApiPath,
		QueueName:            getEnvWithFatal("SLURM_QUEUE_NAME"),
		AuthToken:            "", // Initial token will be generated
		TokenRefreshInterval: time.Duration(tokenRefreshHours) * time.Hour,
		JWTKeyPath:           jwtKeyPath,
		JWTUsername:          jwtUsername,
		JWTExpirationSecs:    jwtExpirationSecs,
	}
}

// initLocalSlurmConfig initializes and returns local Slurm configuration
func initLocalSlurmConfig() sw.SlurmConfig {
	// Get the partition from environment, with a default if not set
	partition := getEnvWithDefault("SLURM_PARTITION", "normal")

	// Create a basic configuration with only the critical parameter (partition)
	// Other parameters will use defaults or be set per-job
	return sw.SlurmConfig{
		Partition: partition,
		QueueName: getEnvWithDefault("SLURM_QUEUE_NAME", ""),
	}
}

// initScheduler initializes and returns a scheduler based on environment configuration
func initScheduler(jobTracker sw.JobTracker) sw.SchedulerInterface {
	schedulerType := getEnvWithDefault("SCHEDULER_TYPE", "SlurmRestScheduler")

	switch schedulerType {
	case "SlurmRestScheduler":
		config := initSlurmRestConfig()
		return sw.NewSlurmRestScheduler(config, jobTracker)
	case "SlurmScheduler":
		config := initLocalSlurmConfig()
		return sw.NewSlurmScheduler(config, jobTracker)
	default:
		log.Fatalf("Unknown scheduler type: %s", schedulerType)
		return nil
	}
}

// initSessionService initializes the session service for user authentication and session management
func initSessionService(sessionTracker sw.SessionTracker) *sw.SessionService {
	// Check if session service is enabled
	enabled := getEnvWithDefault("USER_TOKEN_ENABLED", "true") == "true"
	if !enabled {
		log.Println("Session service is disabled")
		return nil
	}

	// Get JWT key path from environment or use default
	jwtKeyPath := getEnvWithDefault("USER_JWT_KEY_PATH", "")
	// Use SLURM JWT key if user key is not specified
	if jwtKeyPath == "" {
		slurmKeyPath := getEnvWithDefault("JWT_KEY_PATH", "")
		if slurmKeyPath != "" {
			log.Printf("Using Slurm JWT key for user tokens: %s", slurmKeyPath)
			jwtKeyPath = slurmKeyPath
		} else {
			log.Fatalf("No JWT key specified for user tokens")
			return nil
		}
	}

	// Get token expiration from environment or use default
	expirationSecs := int64(86400) // Default to 24 hours

	// Create token config
	config := sw.TokenConfig{
		KeyPath:         jwtKeyPath,
		Username:        "datamonkey",
		ExpirationSecs:  expirationSecs,
		RefreshInterval: 12 * time.Hour,
	}

	// Create session service
	sessionService := sw.NewSessionService(config, sessionTracker)

	// Start session cleanup task (runs every hour, removes sessions older than 30 days)
	cleanupInterval := 1 * time.Hour
	sessionMaxAge := 30 * 24 * time.Hour
	sessionService.StartSessionCleanup(cleanupInterval, sessionMaxAge)

	log.Printf("Initialized session service with key path: %s", jwtKeyPath)
	return sessionService
}

// initAPIHandlers initializes the API handlers with the given components
func initAPIHandlers(scheduler sw.SchedulerInterface, datasetTracker sw.DatasetTracker, jobTracker sw.JobTracker, conversationTracker sw.ConversationTracker, vizTracker sw.VisualizationTracker, sessionService *sw.SessionService) sw.ApiHandleFunctions {
	// Get HyPhy executable path from environment or use default
	hyPhyPath := getEnvWithDefault("HYPHY_PATH", "hyphy")
	// TODO: change this default so that upload files and log/ results are stored in a different directory
	basePath := getEnvWithDefault("HYPHY_BASE_PATH", "/data/uploads")

	// Initialize Genkit client for chat functionality
	modelConfig := sw.GetModelConfig()
	genkitClient, err := sw.NewGenkitClient(context.Background(), modelConfig)
	if err != nil {
		log.Printf("Warning: Failed to initialize Genkit client: %v", err)
		log.Printf("Chat functionality will be disabled. Set GOOGLE_API_KEY, OPENAI_API_KEY, or ANTHROPIC_API_KEY to enable AI features.")
		genkitClient = nil
	} else {
		// Set the base URL for API endpoints used by agentic tools
		apiHost := getEnvWithDefault("API_HOST", "localhost")
		apiPort := getEnvWithDefault("SERVICE_DATAMONKEY_PORT", "9300")
		genkitClient.BaseURL = fmt.Sprintf("http://%s:%s", apiHost, apiPort)
		log.Printf("Genkit client configured with API base URL: %s", genkitClient.BaseURL)
	}

	// Create API handlers
	absrelAPI := sw.NewABSRELAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	felAPI := sw.NewFELAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	bustedAPI := sw.NewBUSTEDAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	slacAPI := sw.NewSLACAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	multihitAPI := sw.NewMULTIHITAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	gardAPI := sw.NewGARDAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	memeAPI := sw.NewMEMEAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	fubarAPI := sw.NewFUBARAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	contrastfelAPI := sw.NewCONTRASTFELAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	relaxAPI := sw.NewRELAXAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	bgmAPI := sw.NewBGMAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	nrmAPI := sw.NewNRMAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	fadeAPI := sw.NewFADEAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)
	slatkinAPI := sw.NewSLATKINAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker)

	// Set the SessionService for each API
	if sessionService != nil {
		absrelAPI.HyPhyBaseAPI.SessionService = sessionService
		felAPI.HyPhyBaseAPI.SessionService = sessionService
		bustedAPI.HyPhyBaseAPI.SessionService = sessionService
		slacAPI.HyPhyBaseAPI.SessionService = sessionService
		multihitAPI.HyPhyBaseAPI.SessionService = sessionService
		gardAPI.HyPhyBaseAPI.SessionService = sessionService
		memeAPI.HyPhyBaseAPI.SessionService = sessionService
		fubarAPI.HyPhyBaseAPI.SessionService = sessionService
		contrastfelAPI.HyPhyBaseAPI.SessionService = sessionService
		relaxAPI.HyPhyBaseAPI.SessionService = sessionService
		bgmAPI.HyPhyBaseAPI.SessionService = sessionService
		nrmAPI.HyPhyBaseAPI.SessionService = sessionService
		fadeAPI.HyPhyBaseAPI.SessionService = sessionService
		slatkinAPI.HyPhyBaseAPI.SessionService = sessionService
	}

	// Create JobsAPI
	jobsAPI := sw.NewJobsAPI(jobTracker, sessionService, scheduler)

	// Create MethodsAPI
	methodsAPI := sw.NewMethodsAPIService()

	// Create VisualizationsAPI
	visualizationsAPI := sw.NewVisualizationsAPI(vizTracker, sessionService)

	return sw.ApiHandleFunctions{
		ABSRELAPI:          *absrelAPI,
		FELAPI:             *felAPI,
		BUSTEDAPI:          *bustedAPI,
		SLACAPI:            *slacAPI,
		MULTIHITAPI:        *multihitAPI,
		GARDAPI:            *gardAPI,
		MEMEAPI:            *memeAPI,
		FUBARAPI:           *fubarAPI,
		CONTRASTFELAPI:     *contrastfelAPI,
		RELAXAPI:           *relaxAPI,
		BGMAPI:             *bgmAPI,
		NRMAPI:             *nrmAPI,
		FADEAPI:            *fadeAPI,
		SLATKINAPI:         *slatkinAPI,
		FileUploadAndQCAPI: *sw.NewFileUploadAndQCAPI(datasetTracker, sessionService),
		HealthAPI: sw.HealthAPI{
			Scheduler:           scheduler,
			DatasetTracker:      datasetTracker,
			JobTracker:          jobTracker,
			ConversationTracker: conversationTracker,
			GenkitClient:        genkitClient,
		},
		JobsAPI:           *jobsAPI,
		MethodsAPI:        methodsAPI,
		ChatAPI:           *sw.NewChatAPI(genkitClient, conversationTracker, sessionService),
		VisualizationsAPI: *visualizationsAPI,
	}
}

func main() {
	// Initialize unified database
	db := initUnifiedDB()
	defer db.Close()

	// Initialize trackers
	dataDir := getEnvWithDefault("DATASET_LOCATION", "/data/uploads")
	datasetTracker := sw.NewSQLiteDatasetTracker(db.GetDB(), dataDir)
	jobTracker := sw.NewSQLiteJobTracker(db.GetDB())
	sessionTracker := sw.NewSQLiteSessionTracker(db.GetDB())
	conversationTracker := sw.NewSQLiteConversationTracker(db.GetDB())
	vizTracker := sw.NewSQLiteVisualizationTracker(db.GetDB())

	// Initialize scheduler
	scheduler := initScheduler(jobTracker)

	// Create the method factory
	hyphyPath := getEnvWithDefault("HYPHY_PATH", "hyphy")
	basePath := getEnvWithDefault("HYPHY_BASE_PATH", "/data/uploads")
	methodFactory := func(methodType sw.HyPhyMethodType) (sw.ComputeMethodInterface, error) {
		return sw.NewHyPhyMethod(nil, basePath, hyphyPath, methodType, ""), nil
	}

	// Initialize and start the job status monitor
	// This is used to update the job status in the database
	monitorInterval := 30 * time.Second // Check job statuses every 30 seconds
	jobMonitor := sw.NewJobStatusMonitor(jobTracker, scheduler, methodFactory, monitorInterval)
	jobMonitor.Start()
	defer jobMonitor.Stop()

	// Initialize session service
	sessionService := initSessionService(sessionTracker)

	// Ensure proper shutdown of components
	if slurmScheduler, ok := scheduler.(*sw.SlurmRestScheduler); ok {
		// Set up graceful shutdown
		defer slurmScheduler.Shutdown()
		log.Println("Token refresh service initialized")
	}

	// Initialize API handlers
	routes := initAPIHandlers(scheduler, datasetTracker, jobTracker, conversationTracker, vizTracker, sessionService)

	// Start server
	port := getEnvWithDefault("SERVICE_DATAMONKEY_PORT", "9300")
	log.Printf("Server starting on port %s", port)
	if err := sw.NewRouter(routes).Run(fmt.Sprintf(":%s", port)); err != nil {
		log.Fatalf("Server error: %v", err)
	}
}
