/*
 * Datamonkey API
 *
 * Datamonkey is a free public server for comparative analysis of sequence alignments using state-of-the-art statistical models. <br> This is the OpenAPI definition for the Datamonkey API.
 *
 * API version: 1.0.0
 * Contact: spond@temple.edu
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package datamonkey

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

type MEMEAPI struct {
	HyPhyBaseAPI
}

// NewMEMEAPI creates a new MEMEAPI instance
func NewMEMEAPI(basePath, hyPhyPath string, scheduler SchedulerInterface, datasetTracker DatasetTracker, jobTracker JobTracker) *MEMEAPI {
	return &MEMEAPI{
		HyPhyBaseAPI: NewHyPhyBaseAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker),
	}
}

// formatMEMEJobResults formats the raw JSON results for MEME jobs
func (api *MEMEAPI) formatMEMEJobResults(jobId string, rawResults json.RawMessage) (map[string]interface{}, error) {
	// Log the raw results for debugging
	log.Printf("Raw results: %s", string(rawResults))

	// Check if the raw results are valid JSON
	var testMap map[string]interface{}
	if err := json.Unmarshal(rawResults, &testMap); err != nil {
		log.Printf("Raw results are not valid JSON: %v", err)
	} else {
		log.Printf("Raw results are valid JSON with %d top-level keys", len(testMap))
		for k := range testMap {
			log.Printf("Found top-level key: %s", k)
		}
	}

	// Create a wrapper structure to match the expected format
	wrappedJSON := fmt.Sprintf(`{"job_id":"%s","result":%s}`, jobId, string(rawResults))
	log.Printf("Wrapped JSON: %s", wrappedJSON)

	var memeResult MemeResult
	if err := json.Unmarshal([]byte(wrappedJSON), &memeResult); err != nil {
		log.Printf("Error unmarshaling wrapped results: %v", err)
		// Try to unmarshal as a generic map to see what's in there
		var resultAsMap map[string]interface{}
		if mapErr := json.Unmarshal(rawResults, &resultAsMap); mapErr != nil {
			log.Printf("Error unmarshaling as map: %v", mapErr)
		} else {
			log.Printf("Results as map: %+v", resultAsMap)
		}
		return nil, fmt.Errorf("failed to parse results: %v", err)
	}

	// Log the parsed result structure
	log.Printf("Parsed MemeResult: %+v", memeResult)

	// Return the result directly as a map to match the API spec
	// The spec expects: {"job_id": "...", "result": {...}}
	resultMap := map[string]interface{}{
		"job_id": jobId,

		"result": memeResult.Result,
	}

	return resultMap, nil
}

// GetMEMEJob retrieves the status and results of a MEME job
func (api *MEMEAPI) GetMEMEJob(c *gin.Context) {
	// Require valid token for accessing results
	if api.SessionService != nil {
		_, err := api.SessionService.GetSubject(c)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - valid token required to access job results"})
			return
		}
	}

	var request MemeRequest
	if err := c.BindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to parse job configuration"})
		return
	}

	adapted, err := AdaptRequest(&request)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to adapt request: %v", err)})
		return
	}

	result, err := api.HandleGetJob(c, adapted, MethodMEME)
	if err != nil {
		if err.Error() == "job is not complete" {
			c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		return
	}

	// Parse the raw JSON results into MemeResult
	resultMap := result.(map[string]interface{})

	// Get the job ID from the result map
	jobId := resultMap["jobId"].(string)

	// Get the raw results
	rawResults := resultMap["results"].(json.RawMessage)

	// Format the results using the shared utility function
	formattedResult, err := api.formatMEMEJobResults(jobId, rawResults)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, formattedResult)
}

// GetMEMEJobById retrieves the status and results of a MEME job by job ID from query parameter
func (api *MEMEAPI) GetMEMEJobById(c *gin.Context) {
	// Require valid token for accessing results
	if api.SessionService != nil {
		_, err := api.SessionService.GetSubject(c)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - valid token required to access job results"})
			return
		}
	}

	// Get job ID from query parameter
	jobId := c.Query("job_id")
	if jobId == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing job_id parameter"})
		return
	}

	// Use the shared helper to get job results
	result, err := api.HyPhyBaseAPI.HandleGetJobById(jobId, MethodMEME)
	if err != nil {
		if err.Error() == "job not found" || err.Error() == "failed to get job status" || strings.Contains(err.Error(), "failed to read results") {
			c.JSON(http.StatusNotFound, gin.H{
				"error":  "Job not found",
				"status": 404,
				"job_id": jobId,
			})
		} else if err.Error() == "job is not complete" {
			c.JSON(http.StatusConflict, gin.H{"error": "Job is not complete"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to get job results: %v", err)})
		}
		return
	}

	// Parse the raw JSON results into MemeResult
	resultMap, ok := result.(map[string]interface{})
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid result format"})
		return
	}

	// Extract the raw JSON results
	rawResults, ok := resultMap["results"].(json.RawMessage)
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid results format"})
		return
	}

	// Format the results using the shared utility function
	formattedResult, err := api.formatMEMEJobResults(jobId, rawResults)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, formattedResult)
}

// StartMEMEJob starts a new MEME analysis job
func (api *MEMEAPI) StartMEMEJob(c *gin.Context) {
	// Require valid token - job start requires referencing existing datasets
	var subject string
	if api.SessionService != nil {
		var err error
		subject, err = api.SessionService.GetSubject(c)
		if err != nil {
			// Token validation failed
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - valid token required to start jobs"})
			return
		}
	}

	var request MemeRequest
	if err := c.BindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to parse job configuration"})
		return
	}

	// Set the subject in the request for job tracking
	if subject != "" {
		request.UserToken = subject
	}

	// Check alignment dataset access
	if request.Alignment != "" && api.SessionService != nil && api.DatasetTracker != nil {
		_, err := api.SessionService.CheckDatasetAccess(c, request.Alignment, api.DatasetTracker)
		if err != nil {
			if strings.Contains(err.Error(), "not found") {
				c.JSON(http.StatusNotFound, gin.H{"error": "Alignment dataset not found"})
				return
			}
			c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden - You don't have access to this alignment"})
			return
		}
	}

	// Check tree dataset access
	if request.Tree != "" && api.SessionService != nil && api.DatasetTracker != nil {
		_, err := api.SessionService.CheckDatasetAccess(c, request.Tree, api.DatasetTracker)
		if err != nil {
			if strings.Contains(err.Error(), "not found") {
				c.JSON(http.StatusNotFound, gin.H{"error": "Tree dataset not found"})
				return
			}
			c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden - You don't have access to this tree"})
			return
		}
	}

	adapted, err := AdaptRequest(&request)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to adapt request: %v", err)})
		return
	}

	result, err := api.HandleStartJob(c, adapted, MethodMEME)
	if err != nil {
		if err.Error() == "authentication token required" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		return
	}

	c.JSON(http.StatusOK, result)
}
