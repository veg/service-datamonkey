/*
 * Datamonkey API
 *
 * Datamonkey is a free public server for comparative analysis of sequence alignments using state-of-the-art statistical models. <br> This is the OpenAPI definition for the Datamonkey API.
 *
 * API version: 1.0.0
 * Contact: spond@temple.edu
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package datamonkey

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

type BGMAPI struct {
	HyPhyBaseAPI
}

// NewBGMAPI creates a new BGMAPI instance
func NewBGMAPI(basePath, hyPhyPath string, scheduler SchedulerInterface, datasetTracker DatasetTracker) *BGMAPI {
	return &BGMAPI{
		HyPhyBaseAPI: NewHyPhyBaseAPI(basePath, hyPhyPath, scheduler, datasetTracker),
	}
}

// formatBGMJobResults formats the raw JSON results for BGM jobs
func (api *BGMAPI) formatBGMJobResults(jobId string, rawResults json.RawMessage) (map[string]interface{}, error) {
	// Log the raw results for debugging
	log.Printf("Raw results: %s", string(rawResults))

	// Check if the raw results are valid JSON
	var testMap map[string]interface{}
	if err := json.Unmarshal(rawResults, &testMap); err != nil {
		log.Printf("Raw results are not valid JSON: %v", err)
	} else {
		log.Printf("Raw results are valid JSON with %d top-level keys", len(testMap))
		for k := range testMap {
			log.Printf("Found top-level key: %s", k)
		}
	}

	// Create a wrapper structure to match the expected format
	wrappedJSON := fmt.Sprintf(`{"job_id":"%s","result":%s}`, jobId, string(rawResults))
	log.Printf("Wrapped JSON: %s", wrappedJSON)

	var bgmResult BgmResult
	if err := json.Unmarshal([]byte(wrappedJSON), &bgmResult); err != nil {
		log.Printf("Error unmarshaling wrapped results: %v", err)
		// Try to unmarshal as a generic map to see what's in there
		var resultAsMap map[string]interface{}
		if mapErr := json.Unmarshal(rawResults, &resultAsMap); mapErr != nil {
			log.Printf("Error unmarshaling as map: %v", mapErr)
		} else {
			log.Printf("Results as map: %+v", resultAsMap)
		}
		return nil, fmt.Errorf("failed to parse results: %v", err)
	}

	// Log the parsed result structure
	log.Printf("Parsed BgmResult: %+v", bgmResult)

	// Create the response map
	resultMap := map[string]interface{}{
		"jobId":   jobId,
		"status":  JobStatusComplete,
		"results": bgmResult.Result,
	}

	return resultMap, nil
}

// GetBGMJob retrieves the status and results of a BGM job
func (api *BGMAPI) GetBGMJob(c *gin.Context) {
	var request BgmRequest
	if err := c.BindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to parse job configuration"})
		return
	}

	adapted, err := AdaptRequest(&request)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to adapt request: %v", err)})
		return
	}

	result, err := api.HandleGetJob(c, adapted, MethodBGM)
	if err != nil {
		if err.Error() == "job is not complete" {
			c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		return
	}

	// Parse the raw JSON results into BgmResult
	resultMap := result.(map[string]interface{})

	// Get the job ID from the result map
	jobId := resultMap["jobId"].(string)

	// Get the raw results
	rawResults := resultMap["results"].(json.RawMessage)

	// Format the results using the shared utility function
	formattedResult, err := api.formatBGMJobResults(jobId, rawResults)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, formattedResult)
}

// GetBGMJobById retrieves the status and results of a BGM job by job ID from query parameter
func (api *BGMAPI) GetBGMJobById(c *gin.Context) {
	// Get job ID from query parameter
	jobId := c.Query("job_id")
	if jobId == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing job_id parameter"})
		return
	}

	// Use the shared helper to get job results
	result, err := api.HyPhyBaseAPI.HandleGetJobById(jobId, MethodBGM)
	if err != nil {
		if err.Error() == "job not found" || err.Error() == "failed to get job status" || strings.Contains(err.Error(), "failed to read results") {
			c.JSON(http.StatusNotFound, gin.H{
				"error":  "Job not found",
				"status": 404,
				"job_id": jobId,
			})
		} else if err.Error() == "job is not complete" {
			c.JSON(http.StatusConflict, gin.H{"error": "Job is not complete"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to get job results: %v", err)})
		}
		return
	}

	// Parse the raw JSON results into BgmResult
	resultMap, ok := result.(map[string]interface{})
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid result format"})
		return
	}

	// Extract the raw JSON results
	rawResults, ok := resultMap["results"].(json.RawMessage)
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid results format"})
		return
	}

	// Format the results using the shared utility function
	formattedResult, err := api.formatBGMJobResults(jobId, rawResults)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, formattedResult)
}

// StartBGMJob starts a new BGM analysis job
func (api *BGMAPI) StartBGMJob(c *gin.Context) {
	var request BgmRequest
	if err := c.BindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to parse job configuration"})
		return
	}

	adapted, err := AdaptRequest(&request)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to adapt request: %v", err)})
		return
	}

	result, err := api.HandleStartJob(c, adapted, MethodBGM)
	if err != nil {
		if err.Error() == "authentication token required" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		return
	}

	c.JSON(http.StatusOK, result)
}
