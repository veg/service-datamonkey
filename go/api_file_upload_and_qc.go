/*
 * Datamonkey API
 *
 * Datamonkey is a free public server for comparative analysis of sequence alignments using state-of-the-art statistical models. <br> This is the OpenAPI definition for the Datamonkey API.
 *
 * API version: 1.0.0
 * Contact: spond@temple.edu
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package datamonkey

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

type FileUploadAndQCAPI struct {
	datasetTracker DatasetTracker
	sessionService *SessionService
}

func NewFileUploadAndQCAPI(datasetTracker DatasetTracker, sessionService *SessionService) *FileUploadAndQCAPI {
	return &FileUploadAndQCAPI{
		datasetTracker: datasetTracker,
		sessionService: sessionService,
	}
}

// Get /api/v1/datasets
// Get a list of datasets uploaded to Datamonkey
func (api *FileUploadAndQCAPI) GetDatasetsList(c *gin.Context) {
	// Require valid token for listing datasets
	var userToken string
	if api.sessionService != nil {
		var err error
		userToken, err = api.sessionService.GetSubject(c)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - valid token required to list datasets"})
			return
		}
	}

	// List datasets for the authenticated user
	datasets, err := api.datasetTracker.ListByUser(userToken)
	if err != nil {
		log.Printf("Failed to list datasets for user: %v", err)
		c.JSON(500, gin.H{"error": "Failed to list datasets"})
		return
	}

	if len(datasets) == 0 {
		log.Printf("No datasets found")
		c.JSON(200, gin.H{"datasets": []interface{}{}})
		return
	}

	// Convert datasets to response format
	response := make([]gin.H, len(datasets))
	for i, ds := range datasets {
		response[i] = gin.H{
			"id":          ds.GetId(),
			"name":        ds.GetMetadata().Name,
			"type":        ds.GetMetadata().Type,
			"description": ds.GetMetadata().Description,
			"created":     ds.GetMetadata().Created,
			"updated":     ds.GetMetadata().Updated,
		}
	}

	c.JSON(200, gin.H{"datasets": response})
}

// PostDataset handles the uploading of datasets to Datamonkey.
// It processes multipart/form-data request containing files or URLs.
// Only one of file or URL should be present in each request entry.
func (api *FileUploadAndQCAPI) PostDataset(c *gin.Context) {
	log.Printf("Handling POST request to upload a dataset")

	// Get or create user session - automatically adds X-Session-Token header if new
	var subject string
	if api.sessionService != nil {
		var err error
		subject, err = api.sessionService.GetOrCreateSubject(c)
		if err != nil {
			log.Printf("Error with session: %v", err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create or validate session"})
			return
		}
	}

	form, err := c.MultipartForm()
	if err != nil {
		c.JSON(400, gin.H{"error": "Failed to parse multipart form"})
		return
	}

	var file UploadRequest
	if len(form.File["file"]) > 0 {
		fileHeader := form.File["file"][0]

		// Create a temporary file in the system's temp directory
		tempFile, err := os.CreateTemp("", "upload-*")
		if err != nil {
			log.Printf("Error creating temporary file: %v", err)
			c.JSON(500, gin.H{"error": fmt.Sprintf("Failed to create temporary file: %v", err)})
			return
		}
		file.File = tempFile

		// Open the uploaded file
		f, err := fileHeader.Open()
		if err != nil {
			log.Printf("Error opening uploaded file: %v", err)
			c.JSON(400, gin.H{"error": err.Error()})
			return
		}
		defer f.Close()

		// Copy the contents to the temporary file
		log.Printf("Copying uploaded file to temporary file: %s", tempFile.Name())
		_, err = io.Copy(file.File, f)
		if err != nil {
			log.Printf("Error copying file: %v", err)
			c.JSON(400, gin.H{"error": err.Error()})
			return
		}
	} else if len(form.Value["url"]) > 0 {
		file.Url = form.Value["url"][0]
	}

	var meta DatasetMeta
	metaField := c.Request.FormValue("meta")
	if err := json.Unmarshal([]byte(metaField), &meta); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}
	file.Meta = meta

	log.Printf("Processing file with name %s", file.Meta.Name)

	// Validate presence of required metadata fields
	if (file.Meta == DatasetMeta{}) || file.Meta.Name == "" {
		c.JSON(400, gin.H{"error": "File name is required"})
		return
	}
	if file.Meta.Type == "" {
		c.JSON(400, gin.H{"error": "File type is required"})
		return
	}
	if file.File == nil && file.Url == "" {
		c.JSON(400, gin.H{"error": "File or URL is required"})
		return
	}
	if file.File != nil && file.Url != "" {
		c.JSON(400, gin.H{"error": "File and URL cannot be provided together"})
		return
	}

	// Validate the file or URL
	if file.File != nil {
		info, err := file.File.Stat()
		if err != nil {
			c.JSON(400, gin.H{"error": "File is not valid"})
			return
		}
		if info.Size() == 0 {
			c.JSON(400, gin.H{"error": "File size is 0"})
			return
		}
	}

	if file.Url != "" {
		if _, err := os.Stat(file.Url); err != nil {
			c.JSON(400, gin.H{"error": "URL is not valid"})
			return
		}
	}

	// Read the file content first
	var content []byte
	if file.File != nil {
		log.Printf("Reading file %s", file.Meta.Name)
		_, _ = file.File.Seek(0, 0)
		content, err = io.ReadAll(file.File)
		if err != nil {
			c.JSON(500, gin.H{"error": err.Error()})
			return
		}
	} else {
		log.Printf("Downloading file %s from url %s", file.Meta.Name, file.Url)
		resp, err := http.Get(file.Url)
		if err != nil {
			c.JSON(500, gin.H{"error": err.Error()})
			return
		}
		defer resp.Body.Close()
		content, err = io.ReadAll(resp.Body)
		if err != nil {
			c.JSON(500, gin.H{"error": err.Error()})
			return
		}
	}

	// Create the dataset with the content
	dataset := NewBaseDataset(DatasetMetadata{
		Name:        file.Meta.Name,
		Description: file.Meta.Description,
		Type:        file.Meta.Type,
		Created:     time.Now(),
		Updated:     time.Now(),
	}, content)

	// Store the dataset in the tracker with owner FIRST
	// This updates the dataset ID to be user-specific
	if subject != "" {
		if err := api.datasetTracker.StoreWithUser(dataset, subject); err != nil {
			c.JSON(500, gin.H{"error": fmt.Sprintf("Failed to store dataset: %v", err)})
			return
		}
	} else {
		// Fallback to Store without owner if no session service
		if err := api.datasetTracker.Store(dataset); err != nil {
			c.JSON(500, gin.H{"error": fmt.Sprintf("Failed to store dataset: %v", err)})
			return
		}
	}

	// Now use the dataset ID (user-specific hash) as the filename
	// IMPORTANT: This must happen AFTER StoreWithUser which updates the ID
	filename := fmt.Sprintf("%s/%s", api.datasetTracker.GetDatasetDir(), dataset.GetId())

	// Write the file to disk with the correct user-specific ID
	err = os.WriteFile(filename, content, 0644)
	if err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	c.JSON(201, gin.H{"status": "File uploaded successfully", "id": dataset.GetId()})
}

// GetDatasetById retrieves a specific dataset by ID
// GET /api/v1/datasets/:datasetId
func (api *FileUploadAndQCAPI) GetDatasetById(c *gin.Context) {
	// Require valid token for accessing datasets
	var userToken string
	if api.sessionService != nil {
		var err error
		userToken, err = api.sessionService.GetSubject(c)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - valid token required to access datasets"})
			return
		}
	}

	datasetId := c.Param("datasetId")

	if datasetId == "" {
		c.JSON(400, gin.H{"error": "Dataset ID is required"})
		return
	}

	// Get dataset and verify ownership
	dataset, err := api.datasetTracker.GetByUser(datasetId, userToken)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			c.JSON(http.StatusNotFound, gin.H{"error": "Dataset not found"})
		} else {
			c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden - you don't have access to this dataset"})
		}
		return
	}

	// Return dataset metadata and optionally content
	metadata := dataset.GetMetadata()
	response := gin.H{
		"id":          dataset.GetId(),
		"name":        metadata.Name,
		"type":        metadata.Type,
		"description": metadata.Description,
		"created":     metadata.Created,
		"updated":     metadata.Updated,
	}

	// Include content if requested via query parameter
	if c.Query("include_content") == "true" {
		datasetPath := fmt.Sprintf("%s/%s", api.datasetTracker.GetDatasetDir(), dataset.GetId())
		content, err := os.ReadFile(datasetPath)
		if err == nil {
			response["content"] = string(content)
		}
	}

	c.JSON(200, response)
}

// DeleteDataset deletes a dataset by ID
// DELETE /api/v1/datasets/:datasetId
func (api *FileUploadAndQCAPI) DeleteDataset(c *gin.Context) {
	// Require valid token for deleting datasets
	var userToken string
	if api.sessionService != nil {
		var err error
		userToken, err = api.sessionService.GetSubject(c)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - valid token required to delete datasets"})
			return
		}
	}

	datasetId := c.Param("datasetId")

	if datasetId == "" {
		c.JSON(400, gin.H{"error": "Dataset ID is required"})
		return
	}

	// Verify dataset exists and user owns it
	_, err := api.datasetTracker.GetByUser(datasetId, userToken)
	if err != nil {
		if strings.Contains(err.Error(), "not found") {
			c.JSON(http.StatusNotFound, gin.H{"error": "Dataset not found"})
		} else {
			c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden - you don't have access to this dataset"})
		}
		return
	}

	// Delete dataset file from disk
	datasetPath := fmt.Sprintf("%s/%s", api.datasetTracker.GetDatasetDir(), datasetId)
	if err := os.Remove(datasetPath); err != nil && !os.IsNotExist(err) {
		log.Printf("Failed to delete dataset file %s: %v", datasetPath, err)
		c.JSON(500, gin.H{"error": "Failed to delete dataset file"})
		return
	}

	// Remove from tracker
	if err := api.datasetTracker.DeleteByUser(datasetId, userToken); err != nil {
		log.Printf("Failed to delete dataset %s from tracker: %v", datasetId, err)
		c.JSON(500, gin.H{"error": "Failed to delete dataset from tracker"})
		return
	}

	log.Printf("Dataset %s deleted successfully by user %s", datasetId, userToken)
	c.Status(204) // No Content
}
