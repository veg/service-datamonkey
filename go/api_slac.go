/*
 * Datamonkey API
 *
 * Datamonkey is a free public server for comparative analysis of sequence alignments using state-of-the-art statistical models. <br> This is the OpenAPI definition for the Datamonkey API.
 *
 * API version: 1.0.0
 * Contact: spond@temple.edu
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package datamonkey

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

type SLACAPI struct {
	HyPhyBaseAPI
}

// NewSLACAPI creates a new SLACAPI instance
func NewSLACAPI(basePath, hyPhyPath string, scheduler SchedulerInterface, datasetTracker DatasetTracker) *SLACAPI {
	return &SLACAPI{
		HyPhyBaseAPI: NewHyPhyBaseAPI(basePath, hyPhyPath, scheduler, datasetTracker),
	}
}

// formatSLACJobResults formats the raw JSON results for SLAC jobs
func (api *SLACAPI) formatSLACJobResults(jobId string, rawResults json.RawMessage) (map[string]interface{}, error) {
	// Log the raw results for debugging
	log.Printf("Raw results: %s", string(rawResults))

	// Check if the raw results are valid JSON
	var testMap map[string]interface{}
	if err := json.Unmarshal(rawResults, &testMap); err != nil {
		log.Printf("Raw results are not valid JSON: %v", err)
	} else {
		log.Printf("Raw results are valid JSON with %d top-level keys", len(testMap))
		for k := range testMap {
			log.Printf("Found top-level key: %s", k)
		}
	}

	// Create a wrapper structure to match the expected format
	wrappedJSON := fmt.Sprintf(`{"job_id":"%s","result":%s}`, jobId, string(rawResults))
	log.Printf("Wrapped JSON: %s", wrappedJSON)

	var slacResult SlacResult
	if err := json.Unmarshal([]byte(wrappedJSON), &slacResult); err != nil {
		log.Printf("Error unmarshaling wrapped results: %v", err)
		// Try to unmarshal as a generic map to see what's in there
		var resultAsMap map[string]interface{}
		if mapErr := json.Unmarshal(rawResults, &resultAsMap); mapErr != nil {
			log.Printf("Error unmarshaling as map: %v", mapErr)
		} else {
			log.Printf("Results as map: %+v", resultAsMap)
		}
		return nil, fmt.Errorf("failed to parse results: %v", err)
	}

	// Log the parsed result structure
	log.Printf("Parsed SlacResult: %+v", slacResult)

	// Create the response map
	resultMap := map[string]interface{}{
		"jobId":   jobId,
		"status":  JobStatusComplete,
		"results": slacResult.Result,
	}

	return resultMap, nil
}

// GetSLACJob retrieves the status and results of a SLAC job
func (api *SLACAPI) GetSLACJob(c *gin.Context) {
	var request SlacRequest
	if err := c.BindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to parse job configuration"})
		return
	}

	adapted, err := AdaptRequest(&request)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to adapt request: %v", err)})
		return
	}

	result, err := api.HandleGetJob(c, adapted, MethodSLAC)
	if err != nil {
		if err.Error() == "job is not complete" {
			c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		return
	}

	// Parse the raw JSON results into SlacResult
	resultMap := result.(map[string]interface{})

	// Get the job ID from the result map
	jobId := resultMap["jobId"].(string)

	// Get the raw results
	rawResults := resultMap["results"].(json.RawMessage)

	// Format the results using the shared utility function
	formattedResult, err := api.formatSLACJobResults(jobId, rawResults)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, formattedResult)
}

// GetSLACJobById retrieves the status and results of a SLAC job by job ID from query parameter
func (api *SLACAPI) GetSLACJobById(c *gin.Context) {
	// Get job ID from query parameter
	jobId := c.Query("job_id")
	if jobId == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing job_id parameter"})
		return
	}

	// Use the shared helper to get job results
	result, err := api.HyPhyBaseAPI.HandleGetJobById(jobId, MethodSLAC)
	if err != nil {
		if err.Error() == "job not found" || err.Error() == "failed to get job status" || strings.Contains(err.Error(), "failed to read results") {
			c.JSON(http.StatusNotFound, gin.H{
				"error":  "Job not found",
				"status": 404,
				"job_id": jobId,
			})
		} else if err.Error() == "job is not complete" {
			c.JSON(http.StatusConflict, gin.H{"error": "Job is not complete"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to get job results: %v", err)})
		}
		return
	}

	// Parse the raw JSON results into SlacResult
	resultMap, ok := result.(map[string]interface{})
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid result format"})
		return
	}

	// Extract the raw JSON results
	rawResults, ok := resultMap["results"].(json.RawMessage)
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid results format"})
		return
	}

	// Format the results using the shared utility function
	formattedResult, err := api.formatSLACJobResults(jobId, rawResults)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, formattedResult)
}

// StartSLACJob starts a new SLAC analysis job
func (api *SLACAPI) StartSLACJob(c *gin.Context) {
	var request SlacRequest
	if err := c.BindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to parse job configuration"})
		return
	}

	adapted, err := AdaptRequest(&request)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to adapt request: %v", err)})
		return
	}

	result, err := api.HandleStartJob(c, adapted, MethodSLAC)
	if err != nil {
		if err.Error() == "authentication token required" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		return
	}

	c.JSON(http.StatusOK, result)
}
