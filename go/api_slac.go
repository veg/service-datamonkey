/*
 * Datamonkey API
 *
 * Datamonkey is a free public server for comparative analysis of sequence alignments using state-of-the-art statistical models. <br> This is the OpenAPI definition for the Datamonkey API.
 *
 * API version: 1.0.0
 * Contact: spond@temple.edu
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package datamonkey

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

type SLACAPI struct {
	HyPhyBaseAPI
}

// NewSLACAPI creates a new SLACAPI instance
func NewSLACAPI(basePath, hyPhyPath string, scheduler SchedulerInterface, datasetTracker DatasetTracker, jobTracker JobTracker) *SLACAPI {
	return &SLACAPI{
		HyPhyBaseAPI: NewHyPhyBaseAPI(basePath, hyPhyPath, scheduler, datasetTracker, jobTracker),
	}
}

// formatSLACJobResults formats the raw JSON results for SLAC jobs
func (api *SLACAPI) formatSLACJobResults(jobId string, rawResults json.RawMessage) (map[string]interface{}, error) {
	// Log the raw results for debugging
	log.Printf("Raw results: %s", string(rawResults))

	// Check if the raw results are valid JSON
	var testMap map[string]interface{}
	if err := json.Unmarshal(rawResults, &testMap); err != nil {
		log.Printf("Raw results are not valid JSON: %v", err)
	} else {
		log.Printf("Raw results are valid JSON with %d top-level keys", len(testMap))
		for k := range testMap {
			log.Printf("Found top-level key: %s", k)
		}
	}

	// Create a wrapper structure to match the expected format
	wrappedJSON := fmt.Sprintf(`{"job_id":"%s","result":%s}`, jobId, string(rawResults))
	log.Printf("Wrapped JSON: %s", wrappedJSON)

	var slacResult SlacResult
	if err := json.Unmarshal([]byte(wrappedJSON), &slacResult); err != nil {
		log.Printf("Error unmarshaling wrapped results: %v", err)
		// Try to unmarshal as a generic map to see what's in there
		var resultAsMap map[string]interface{}
		if mapErr := json.Unmarshal(rawResults, &resultAsMap); mapErr != nil {
			log.Printf("Error unmarshaling as map: %v", mapErr)
		} else {
			log.Printf("Results as map: %+v", resultAsMap)
		}
		return nil, fmt.Errorf("failed to parse results: %v", err)
	}

	// Log the parsed result structure
	log.Printf("Parsed SlacResult: %+v", slacResult)

	// Return the SlacResult directly as a map to match the API spec
	// The spec expects: {"job_id": "...", "result": {...}}
	resultMap := map[string]interface{}{
		"job_id": jobId,
		"result": slacResult.Result,
	}

	return resultMap, nil
}

// GetSLACJob retrieves the status and results of a SLAC job
func (api *SLACAPI) GetSLACJob(c *gin.Context) {
	// Validate user token if token validator is available
	if api.UserTokenValidator != nil {
		// Just validate the token exists and is valid
		_, err := api.UserTokenValidator.ValidateUserToken(c)
		if err != nil {
			if err.Error() == "missing user token" || strings.Contains(err.Error(), "invalid user token") {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - " + err.Error()})
				return
			}

			c.JSON(http.StatusInternalServerError, gin.H{"error": "Authentication error: " + err.Error()})
			return
		}
	}

	var request SlacRequest
	if err := c.BindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to parse job configuration"})
		return
	}

	adapted, err := AdaptRequest(&request)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to adapt request: %v", err)})
		return
	}

	result, err := api.HandleGetJob(c, adapted, MethodSLAC)
	if err != nil {
		if err.Error() == "job is not complete" {
			c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		return
	}

	// Parse the raw JSON results into SlacResult
	resultMap := result.(map[string]interface{})

	// Get the job ID from the result map
	jobId := resultMap["jobId"].(string)

	// Check job access now that we have the job ID
	if api.UserTokenValidator != nil {
		_, err := api.UserTokenValidator.CheckJobAccess(c, jobId, api.JobTracker)
		if err != nil {
			if strings.Contains(err.Error(), "missing user token") || strings.Contains(err.Error(), "invalid user token") {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - " + err.Error()})
				return
			}
			c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden - You don't have access to this job"})
			return
		}
	}

	// Get the raw results
	rawResults := resultMap["results"].(json.RawMessage)

	// Format the results using the shared utility function
	formattedResult, err := api.formatSLACJobResults(jobId, rawResults)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, formattedResult)
}

// GetSLACJobById retrieves the status and results of a SLAC job by job ID from query parameter
func (api *SLACAPI) GetSLACJobById(c *gin.Context) {
	// Get job ID from query parameter
	jobId := c.Query("job_id")
	if jobId == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing job_id parameter"})
	}

	// Validate user token and check job access if token validator is available
	if api.UserTokenValidator != nil {
		// Validate the token and check job access
		_, err := api.UserTokenValidator.CheckJobAccess(c, jobId, api.JobTracker)
		if err != nil {
			if err.Error() == "missing user token" || strings.Contains(err.Error(), "invalid user token") {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - " + err.Error()})
				return
			}

			// For other errors, return forbidden
			c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden - You don't have access to this job"})
			return
		}

		log.Printf("User token validated successfully for job %s", jobId)
	}

	// Use the shared helper to get job results
	result, err := api.HyPhyBaseAPI.HandleGetJobById(jobId, MethodSLAC)
	if err != nil {
		if err.Error() == "job not found" || err.Error() == "failed to get job status" || strings.Contains(err.Error(), "failed to read results") {
			c.JSON(http.StatusNotFound, gin.H{
				"error":  "Job not found",
				"status": 404,
				"job_id": jobId,
			})
		} else if err.Error() == "job is not complete" {
			c.JSON(http.StatusConflict, gin.H{"error": "Job is not complete"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to get job results: %v", err)})
		}
		return
	}

	// Parse the raw JSON results into SlacResult
	resultMap, ok := result.(map[string]interface{})
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid result format"})
		return
	}

	// Extract the raw JSON results
	rawResults, ok := resultMap["results"].(json.RawMessage)
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid results format"})
		return
	}

	// Format the results using the shared utility function
	formattedResult, err := api.formatSLACJobResults(jobId, rawResults)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, formattedResult)
}

// StartSLACJob starts a new SLAC analysis job
func (api *SLACAPI) StartSLACJob(c *gin.Context) {
	// Validate user token if token validator is available
	if api.UserTokenValidator != nil {
		// Just validate the token exists and is valid
		_, err := api.UserTokenValidator.ValidateUserToken(c)
		if err != nil {
			if err.Error() == "missing user token" || strings.Contains(err.Error(), "invalid user token") {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - " + err.Error()})
				return
			}

			c.JSON(http.StatusInternalServerError, gin.H{"error": "Authentication error: " + err.Error()})
			return
		}
	}

	var request SlacRequest
	if err := c.BindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to parse job configuration"})
		return
	}

	// Extract the user token from the request or from the header/query parameter
	if request.UserToken == "" && api.UserTokenValidator != nil {
		// Try to get token from query parameter first
		userToken := c.Query("user_token")

		// If not in query, try header
		if userToken == "" {
			userToken = c.GetHeader("user_token")
		}

		// Set the token in the request
		if userToken != "" {
			request.UserToken = userToken
		}
	}

	// Check alignment dataset access before starting the job
	if request.Alignment != "" && api.UserTokenValidator != nil && api.DatasetTracker != nil {
		_, err := api.UserTokenValidator.CheckDatasetAccess(c, request.Alignment, api.DatasetTracker)
		if err != nil {
			if strings.Contains(err.Error(), "missing user token") || strings.Contains(err.Error(), "invalid user token") {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - " + err.Error()})
				return
			}
			if strings.Contains(err.Error(), "not found") {
				c.JSON(http.StatusNotFound, gin.H{"error": "Alignment dataset not found"})
				return
			}
			c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden - You don't have access to this alignment"})
			return
		}
	}

	// Check tree dataset access before starting the job
	if request.Tree != "" && api.UserTokenValidator != nil && api.DatasetTracker != nil {
		_, err := api.UserTokenValidator.CheckDatasetAccess(c, request.Tree, api.DatasetTracker)
		if err != nil {
			if strings.Contains(err.Error(), "missing user token") || strings.Contains(err.Error(), "invalid user token") {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized - " + err.Error()})
				return
			}
			if strings.Contains(err.Error(), "not found") {
				c.JSON(http.StatusNotFound, gin.H{"error": "Tree dataset not found"})
				return
			}
			c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden - You don't have access to this tree"})
			return
		}
	}

	adapted, err := AdaptRequest(&request)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Failed to adapt request: %v", err)})
		return
	}

	result, err := api.HandleStartJob(c, adapted, MethodSLAC)
	if err != nil {
		if err.Error() == "authentication token required" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		}
		return
	}

	c.JSON(http.StatusOK, result)
}
